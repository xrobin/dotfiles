# For an explanation of .bashrc, .bash_profile and .profile, see http://superuser.com/questions/789448/choosing-between-bashrc-profile-bash-profile-etc
# In short: environment variables go to .profile, all shell-specific stuff in .bashrc.

# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# In SUSE, /etc/profile force reads our .bashrc before .profile, which causes
# all sorts of issue (incomplete PATH, etc)
# Detect this condition and exit if necessary
# Remember: we read .bashrc from .bash_profile, which is sourced by login shells
if [[ $MACHTYPE == "x86_64-suse-linux" ]] && [[ $SSH_CONNECTION != "" ]]; then
	if [[ $_READ_PROFILE == "" ]]; then
		echo "Detected early sourcing of .bashrc on OpenSUSE. Aborting!"
		OPENSUSE_EARLY_SOURCING=1
		return
	elif [[ "$OPENSUSE_EARLY_SOURCING" == 1 ]]; then
		echo "Detected normal sourcing of .bashrc on OpenSUSE. Proceeding!"
		unset OPENSUSE_EARLY_SOURCING
	fi
fi
# Detect if we are reading .bashrc again and display a message if we are
if [[ "$_READ_BASHRC" == $$ ]]; then
	echo ".bashrc has already been sourced. Sourcing this file multiple times is not recommended. Please check your system for errors."
fi

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# Expands variables to directories
# This prevents $HOME/<TAB> from becoming \$HOME/
shopt -s direxpand

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" -a -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
#case "$TERM" in
#xterm-color)
#    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
#    ;;
#*)
#    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;30m\]\u@\h\[\033[0;34m\]:\[\033[0;32m\]\w\[\033[0;37m\]\$\[\033[00m\] '
#    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
#    PS1='${debian_chroot:+($debian_chroot)}\033[00m\u@\h\033[34m:\033[32m\w\033[37m\$\033[00m\] '
#    ;;
#esac

show_status_in_color(){
    es=$?
    if [ $es -eq 0 ]; then
            echo "$es"
        else
          echo -e "\033[1;31m$es"
        fi
}

PS1_STATUS_PART='$(show_status_in_color)$([[ $DATE_PROMPT == true ]] && echo ": "`date +%Y-%m-%d:%H:%M:%S`)${debian_chroot:+($debian_chroot)}'
# Comment in the above and uncomment this below for a color prompt
#PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
#PS1='${debian_chroot:+($debian_chroot)}\[\033[01;30m\]\u@\h\[\033[0;34m\]:\[\033[0;32m\]\w\[\033[0;37m\]\$\[\033[00m\] '
#PS1='${debian_chroot:+($debian_chroot)}\[\033[01;34m\]\u@\h\[\033[0;37m\]:\[\033[0;32m\]\w\[\033[0;37m\]\$\[\033[00m\] '
# Add the date in the prompt if DATE_PROMPT=true:
#PS1="\[\033[0;37m\]"'$(get_exit_status)'"\[\033[1;34m\]\u\[\033[0;37m\]@\[\033[01;34m\]\h\[\033[0;37m\]:\[\033[0;32m\]\w\[\033[0;37m\]\$\[\033[00m\] "
PS1="\[\033[0;37m\]($PS1_STATUS_PART\[\033[0;37m\])\[\033[1;34m\]\u\[\033[0;37m\]@\[\033[01;34m\]\h\[\033[0;37m\]:\[\033[0;32m\]\w\[\033[0;37m\]\$\[\033[00m\] "

# Change the prompt color when logged on an other machine
if [[ "$SSH_CONNECTION" != "" ]]
then
	PS1="\[\033[0;37m\]$PS1_STATUS_PART\\[\033[01;32m\]\u\[\033[01;30m\]@\[\033[01;35m\]\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ "
fi

if [[ ! -z "$PBS_JOBID" ]]
then
	echo "In PBS job '$PBS_JOBID'"
	PS1="\[\033[0;47m\]$PS1_STATUS_PART\[\033[48;5;10m\]\u\[\033[47m\]\[\033[30m\]@\[\033[48;5;13m\]\h\[\033[47m\]\[\033[30m\]:\[\033[48;5;14m\]\w\[\033[47m\]\[\033[30m\]\$\[$(tput sgr0)\] "
fi

# Red prompt for root
if [[ $UID == 0 ]]
then
	PS1="\[\033[0;37m\]$PS1_STATUS_PART\[\033[01;31m\]\u@\h:\w# \[\033[00m\]"
fi


# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
	PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD/$HOME/~}\007"; history -a;'
    ;;
*)
	PROMPT_COMMAND='history -a'
    ;;
esac

# enable color support of ls and also add handy aliases
if [ "$TERM" != "dumb" ]; then
	if ls --color -d . >/dev/null 2>&1; then
		# We have a GNU ls
		if hash dircolors 2>/dev/null ; then
			# Dircolors is present
			eval "`dircolors -b`"
			alias ls='ls --color=auto'
#    alias dir='ls --color=auto --format=vertical'
#    alias vdir='ls --color=auto --format=long'
		fi
	elif ls -G -d . >/dev/null 2>&1; then
		# We have a BSD ls
		alias ls='ls -G'
	fi 
fi

if [ "`locale language 2>/dev/null`" == "French" ]; then
	FULL_NAME=$(getent passwd "$USER" | cut -d ':' -f 5)
	if [ "$FULL_NAME" != "" ]; then
		echo ""
		read -r -d '' GREETING << EOM
Bienvenue Maître vénéré $FULL_NAME !
Dieu de tous les Dieux !
Soyez productif durant cette journée !
EOM
		if hash cowsay 2>/dev/null; then 
			echo "$GREETING" | awk 'BEGIN{RS="\n" ; ORS="\n\n";}{ print }' | cowsay -W 60 -f $(cowsay -l | tail -n +2 | tr " " "\n" | shuf -n1)
		else
			echo ""
			echo "$GREETING"		
			echo ""
		fi
	fi
elif [ "$SHOW_FORTUNE" = true ]; then
	fortune | cowsay -f $(cowsay -l | tail -n +2 | tr " " "\n" | shuf -n1)
fi

# ne pas historiser cd, ls, bg, fg et clear
export HISTIGNORE="cd:ls:[bf]g:clear"
export HISTSIZE=20000
export HISTFILESIZE=1000000
export HISTCONTROL=ignoredups
export HISTTIMEFORMAT=
shopt -s cmdhist
shopt -s histappend


# make make faster by parallelizing
# Only in interactive shells for safety reasons...
if hash nproc 2>/dev/null; then
	export MAKEFLAGS=-j`nproc`
fi

#/home/xavier/.showcow
[[ -f "$HOME/.config/autopackage/paths-bash" ]] && . "$HOME/.config/autopackage/paths-bash"

export RUBYOPT=-rubygems

#export R_LIBS_USER=/home/xavier/R/lib/

# Enable colors in ls on mac
export CLICOLORS=1

if [ -f ~/.aliases ]; then 
	. ~/.aliases 
fi

if [ -f ~/.aliases.local ]; then 
	. ~/.aliases.local 
fi

# Source additional local files
if test -n "$(shopt -s nullglob; echo ~/.bashrc.*)"
then
	for f in ~/.bashrc.*; do
		if [[ "$f" == *.backup ]]; then
			continue
		fi
		. $f
	done
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
# par exemple si on tappes tar, seul les fichiers tar seront complétés...
if [[ $BASH =~ /bin/bash$ ]]; then
	prefix=${BASH[@]%bin/bash}
fi
if [ -f ${prefix}bash_completion ]; then
    . ${prefix}bash_completion
elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
fi


# Stuff found at http://teaching.idallen.com/cst8207/13w/notes/350_startup_files.html#no-output-allowed-for-non-interactive-shells
#shopt -s failglob # Note: disabled because it inteferes with shopt -s nullglob used above and with bash completion
#set -o ignoreeof
#set -o noclobber
#set -o notify
#set -o nounset
#set -o physical
#set -o interactive-comments

# .* matches . and .. by default
# This creates issue with mv and lists parent folder with ls .* 
# This behavior can be changed <https://superuser.com/questions/178633/can-i-keep-and-out-of-expansion>
GLOBIGNORE=.
shopt -u dotglob

# Google Compute servers have very complicated names
if [[ $HOST =~ lindinglab-.+-opensuse-13-[0-9] ]]; then 
       	export HOST=`echo $HOST | sed 's/lindinglab-\(.\+\)-opensuse-13-[[:digit:]]/\1/'`;
	PS1="`echo $PS1 | sed 's/\\\\h/$HOST/'` "
fi
if [[ $HOSTNAME =~ lindinglab-.+-opensuse-13-[0-9] ]]; then 
	export HOSTNAME=`echo $HOSTNAME | sed 's/lindinglab-\(.\+\)-opensuse-13-[[:digit:]]/\1/'`;
	PS1="`echo $PS1 | sed 's/\\\\h/$HOSTNAME/'` "
fi


# Sends an email alert. Useful to run after long commands
# Ex: some_long_command; mail_alert "some_long_command finished"
if hash mailx 2>/dev/null; then
	function mail_alert {
	        last_exit=$?
	        MSG=$1
	        if [ "$MSG" == "" ]; then
			if [ "$0" == "-bash" ]; then
				MSG="mail_alert"
			else
		                MSG=`basename "$0"`
			fi
	        fi
		echo "Command returned ${last_exit} on $(hostname)." | mailx -s "$MSG" "$USER"
	}
elif hash sendmail 2>/dev/null; then
	function mail_alert {
	        last_exit=$?
	        MSG=$1
	        if [ "$MSG" == "" ]; then
			if [ "$0" == "-bash" ]; then
				MSG="mail_alert"
			else
		                MSG=`basename "$0"`
			fi
	        fi
	        echo -e "Subject: $MSG\n\nCommand returned ${last_exit} on $(hostname)." | sendmail "$USER"
	}
else
	echo "Sendmail/mailx not installed, mail_alert unavailable."
	# Suggest install command on Ubuntu/Debian
	( lsb_release -a 2>/dev/null| grep "\(Ubuntu\|Debian\)" >/dev/null ) && echo "Install sendmail with sudo apt-get install sendmail-bin and log in again to enable mail_alert."
fi


# Remember if the file was read already
_READ_BASHRC=$$
